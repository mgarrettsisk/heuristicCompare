




FUNCTION monteCarloTests()
FOR EACH MAZE ITERATION
	GENERATE a RANDOM MAZE
	FOR EACH START ITERATION
		GENERATE a RANDOM START and FINISH
		SOLVE maze with DFS
		RECORD SOLUTION PATH LENGTH and VISIT COUNTS
		RESET visit counts and solution path
		SOLVE maze with RANDOM WALK
		RECORD SOLUTION PATH LENGTH and VISIT COUNTS
		RESET visit counts and solution path
		SOLVE maze with EUCLIDEAN HEURISTIC
		RECORD SOLUTION PATH LENGTH and VISIT COUNTS
		RESET visit counts and solution path
		SOLVE maze with LOOK AHEAD HEURISTIC
		RECORD SOLUTION PATH LENGTH and VISIT COUNTS
	END FOR
END FOR
WRITE RECORDED RESULTS to OUPUT CSV FILE
END FUNCTION




FUNCTION depthFirstSearch()
WHILE the CURRENT CELL is NOT EQUAL to the GOAL CELL
	ADD the CURRENT CELL to the SOLUTION PATH
	MARK the CURRENT CELL as VISITED
	DETERMINE POSSIBLE MOVES FROM CURRENT CELL
	IF there are NO POSSIBLE MOVES available:
		REMOVE the CURRENT CELL from the SOLUTION PATH
		SET the CURRENT CELL as next in SOLUTION PATH
		REPEAT the WHILE LOOP
	ELSE IF there are POSSIBLE MOVES available:
		CHOOSE the FIRST POSSIBLE MOVE
		SET the CURRENT CELL from FIRST POSSIBLE MOVE
		REPEAT THE LOOP
	END IF
END WHILE
RETURN solutionPathStack
END FUNCTION

FUNCTION determinePossibleMoves()
FOR each NEIGHBORING CELL from CURRENT CELL
	IF the WALL between CURRENT CELL and ADJACENT CELL is a passage ...
	    AND IF the ADJACENT CELL has not been VISITED
		ADD ADJACENT CELL to POSSIBLE MOVES
	END IF
END FOR
RETURN possibleMovesArray
END FUNCTION


FUNCTION randomWalkSearch()
WHILE the CURRENT CELL is NOT EQUAL to the GOAL CELL
	ADD the CURRENT CELL to the SOLUTION PATH
	MARK the CURRENT CELL as VISITED
	DETERMINE POSSIBLE MOVES FROM CURRENT CELL
	IF there are NO POSSIBLE MOVES available:
		REMOVE the CURRENT CELL from the SOLUTION PATH
		SET the CURRENT CELL as next in SOLUTION PATH
		REPEAT the WHILE LOOP
	ELSE IF there are POSSIBLE MOVES available:
		CHOOSE the FIRST POSSIBLE MOVE
		SET the CURRENT CELL from RANDOM POSSIBLE MOVE
		REPEAT THE LOOP
	END IF
END WHILE
RETURN solutionPathStack
END FUNCTION


FUNCTION euclideanSolve()
WHILE the CURRENT CELL is NOT EQUAL to the GOAL CELL
	ADD the CURRENT CELL to the SOLUTION PATH
	MARK the CURRENT CELL as VISITED
	DETERMINE POSSIBLE MOVES FROM CURRENT CELL
	IF there are NO POSSIBLE MOVES available:
		REMOVE the CURRENT CELL from the SOLUTION PATH
		SET the CURRENT CELL as next in SOLUTION PATH
		REPEAT the WHILE LOOP
	ELSE IF there are POSSIBLE MOVES available:
		CHOOSE the FIRST POSSIBLE MOVE
		SET the CURRENT CELL from SHORTEST DISTANCE
		REPEAT THE LOOP
	END IF
END WHILE
RETURN solutionPathStack
END FUNCTION

FUNCTION shortestDistance()
	SET X_1 POSITION, Y_1 POSITION from CURRENT CELL
	SET X_2 POSITION, Y_2 POSITION from GOAL CELL
	RETURN SQRT((X_1 - X_2)^2 + (Y_1 - Y_2)^2)
END FUNCTION



FUNCTION lookAheadSolve()
WHILE the CURRENT CELL is NOT EQUAL to the GOAL CELL
	ADD the CURRENT CELL to the SOLUTION PATH
	MARK the CURRENT CELL as VISITED
	DETERMINE POSSIBLE MOVES FROM CURRENT CELL
	IF there are NO POSSIBLE MOVES available:
		REMOVE the CURRENT CELL from the SOLUTION PATH
		SET the CURRENT CELL as next in SOLUTION PATH
		REPEAT the WHILE LOOP
	ELSE IF there are POSSIBLE MOVES available:
		CHOOSE the FIRST POSSIBLE MOVE
		SET the CURRENT CELL from LOOK AHEAD RESULT
		REPEAT THE LOOP
	END IF
END WHILE
RETURN solutionPathStack
END FUNCTION

FUNCTION lookAheadResult()
FOR all POSSIBLE MOVES
	CREATE new MINI AGENT from ADJACENT CELL
	CALL MINI AGENT TRAVERSE with DEPTH LIMIT
	RETURN THE ADJACENT CELL with CLOSEST TRAVERSE
END FOR
END FUNCTION


FUNCTION miniAgentTraverse()
SET DEPTH LIMIT
WHILE CURRENT CELL is NOT GOAL CELL AND CURRENT DEPTH is LESS THAN DEPTH LIMIT
ADD the CURRENT CELL to the LOOK AHEAD PATH
	MARK the CURRENT CELL as VISITED
	DETERMINE POSSIBLE MOVES FROM CURRENT CELL
	IF there are NO POSSIBLE MOVES available:
		REMOVE the CURRENT CELL from the LOOK AHEAD PATH
		SET the CURRENT CELL as next in LOOK AHEAD PATH
		LOWER CURRENT DEPTH by 1
		REPEAT the WHILE LOOP
	ELSE IF there are POSSIBLE MOVES available:
		SET the CURRENT CELL from SHORTEST DISTANCE
		INCREASE CURRENT DEPTH by 1
		REPEAT THE LOOP
	END IF
END WHILE
RETURN lookAheadStack
END FUNCTION










